https://ivan-shamaev.ru/data-engineering-etl-pipeline-data-warehouse-datalake/
https://tproger.ru/curriculum/data-engineer-interview-guide/
https://bozaro.github.io/tech-db-lectures/
## SQL


#### DDL – Data Definition Language
CREATE – используется для создания объектов базы данных;
ALTER – используется для изменения объектов базы данных;
DROP – используется для удаления объектов базы данных.

#### DML – Data Manipulation Language
SELECT – осуществляет выборку данных;
INSERT – добавляет новые данные;
UPSERT
REPLACE
UPDATE – изменяет существующие данные;
DELETE – удаляет данные.

#### DCL – Data Control Language
GRANT – предоставляет пользователю или группе разрешения на определённые операции с объектом;
REVOKE – отзывает выданные разрешения;
DENY– задаёт запрет, имеющий приоритет над разрешением.

#### TCL – Transaction Control Language
BEGIN TRANSACTION – служит для определения начала транзакции;
COMMIT TRANSACTION – применяет транзакцию;
ROLLBACK TRANSACTION – откатывает все изменения, сделанные в контексте текущей транзакции;
SAVE TRANSACTION – устанавливает промежуточную точку сохранения внутри транзакции.

---

##### Транзакция  
- упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое. Потом 
**COMMIT** - применяем изменения
**ROLLBACK** - откатываем изменения
До закрытия транзакции изменения сохраняются «виртуально»  и после коммита применяются фактически.
Если не делать коммит или ролбек и вернуть конекш(подключение) в пул подключений, то другой человек можем подтвердить изменения прошлого
###### Проблемы параллельного использования транзакций:
1. **Потерянное обновление** - когда у нас в результате изменения блока данных разными транзакциями, сохраняется только последняя.
2. **Грязное чтение** - когда мы можем прочитать данные, которые в последствии откатятся.
3. **Неповторяющееся** чтение - когда у нас в рамках одной транзакции. Чтение одних и тех же данных даёт разный результат 
4. **Фантомное чтение** - когда у нас в рамках одной транзакции есть выборка нескольких строк, а в итоге мы получаем разное количество. 

###### Уровни изоляции транзакций:
1. **Read uncommitted (чтение незафиксированных данных)** - Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно, фактически выполнятся последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются.
2. **Read committed (чтение фиксированных данных)** - пишущая транзакция блокирует изменяемые данные для читающих транзакций, работающих на уровне read committed или более высоком, до своего завершения, препятствуя, таким образом, «грязному» чтению, а данные, блокируемые читающей транзакцией, освобождаются сразу после завершения операции SELECT
3. **Repeatable read (повторяющееся чтение)** - Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие условиям поиска инструкций, содержащихся в текущей транзакции.
4. **Serializable (упорядочиваемость)** - Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения».

###### ACID
* **Atomicity — Атомарность** гарантирует, что никакая транзакция не будет зафиксирована в системе частично. 
Будут либо выполнены все её подоперации, либо не выполнено ни одной.
* **Consistency — Согласованность**
Транзакция, достигающая своего нормального завершения и, фиксирующая свои результаты, сохраняет согласованность базы данных.
Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты.
* **Isolation — Изолированность**
Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.
* **Durability — Долговечность**
Независимо от проблем на нижних уровнях (к примеру, сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу.

###### Термины
* **Первичный ключ** - (выбранный потенциальный ключ - обладает свойствами уникальности и минимальности) уникальный ключ для идентификации записи в таблице.
* **Внешний ключ** — это столбец или сочетание столбцов, которое применяется для принудительного установления связи между данными в двух таблицах с целью контроля данных, которые могут храниться в таблице внешнего ключа.
* **Индекс** в базах данных — это файл с последовательностью пар ключей и указателей на запись в таблице. В виде B-дерева. Также бывает bitmap-индекс - битовая маска.
* **Представление** (англ. view, иногда используются названия «вид», «взгляд») — виртуальная (логическая) таблица, представляющая собой поименованный запрос (синоним к запросу), который будет подставлен как подзапрос при использовании представления. 
В отличие от обычных таблиц реляционных баз данных, представление не является самостоятельной частью набора данных, хранящегося в базе. Содержимое представления динамически вычисляется на основании данных, находящихся в реальных таблицах. Изменение данных в реальной таблице базы данных немедленно отражается в содержимом всех представлений, построенных на основании этой таблицы.

Некоторые СУБД имеют расширенные представления для данных, доступных только для чтения. Так, СУБД Oracle реализует концепцию «материализованных представлений» — представлений, содержащих предварительно выбранные невиртуальные наборы данных, совместно используемых в распределённых базах данных. Эти данные извлекаются из различных удалённых источников (с разных серверов распределённой СУБД). Целостность данных в материализованных представлениях поддерживается за счёт периодических синхронизаций или с использованием триггеров. Аналогичный механизм предусмотрен в Microsoft SQL Server версии 2000.

* **Храни́мая процеду́ра (англ. Stored procedure)** — объект базы данных, представляющий собой набор SQL-инструкций, который компилируется один раз и хранится на сервере. Можно использовать перехват ошибок, нельзя вызывать в SELECT.

Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения

* **Триггер** - хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением INSERT, удалением DELETE строки в заданной таблице, или изменением UPDATE данных в определённом столбце заданной таблицы реляционной базы данных. 

* **Курсор** — это поименованная область памяти, содержащая результирующий набор select запроса. Второе определение — это механизм обработки результирующего набора select запроса.



WINDOW w AS (
PARTITION BY 
ORDER BY
ROWS
)
Границы можно определять рядом выражений:
![image](https://user-images.githubusercontent.com/53166911/179399093-41af7cf4-038e-40f0-a894-9fc77d54cf0c.png)
<img src="[https://github.com/favicon.ico](https://user-images.githubusercontent.com/53166911/179399093-41af7cf4-038e-40f0-a894-9fc77d54cf0c.png)" width="48">
N PRECEDING, N строк до текущей строки
CURRENT ROW, текущая строка
UNBOUNDED PRECEDING, все строки, предшествующие текущей
UNBOUNDED FOLLOWING, все последующие строки
N FOLLOWING, N строк после текущей строки

UNBOUNDED PRECEDING — указывает, что окно начинается с первой строки группы;
UNBOUNDED FOLLOWING – с помощью данной инструкции можно указать, что окно заканчивается на последней строке группы;
CURRENT ROW – инструкция указывает, что окно начинается или заканчивается на текущей строке;
BETWEEN «граница окна» AND «граница окна» — указывает нижнюю и верхнюю границу окна;
«Значение» PRECEDING – определяет число строк перед текущей строкой (не допускается в предложении RANGE).;
«Значение» FOLLOWING — определяет число строк после текущей строки (не допускается в предложении RANGE).

##### 1NF https://otus.ru/nest/post/1812/
Согласно правилам, все атрибуты в такой таблице должны быть простыми, все сохраняемые данные на пересечении столбцов и строк — содержать лишь скалярные значения. Также не должно быть повторяющихся строк. 

##### 2NF
Отношения будут соответствовать 2НФ, если сама БД находится в 1НФ, а каждый столбец, который не является ключом, зависит от первичного ключа.

##### 3NF
Таблица должна находиться во 2НФ, плюс любой столбец, который не является ключом, должен зависеть лишь от первичного ключа.

---
## Python

Сильная динамическая типизация то есть тип переменной определяется только во время исполнения. Поэтому вместо «присваивания значения переменной» лучше говорить о «связывании значения с некоторым именем».

Декораторы
**@staticmethod** нет обязательных параметров-ссылок вроде self. Доступ к таким методам можно получить как из экземпляра класса, так и из самого  класса
```class SomeClass(object):
    @staticmethod
    def hello():
        print("Hello, world")

SomeClass.hello() # Hello, world
obj = SomeClass()
obj.hello() # Hello, world
```

**@classmethod** выполняются не в контексте объекта, а в контексте самого класса  (классы – это тоже объекты). Такие методы создаются с помощью декоратора @classmethod и требуют обязательную ссылку на класс (cls).
```
class SomeClass(object):
    @classmethod
    def hello(cls):
        print('Hello, класс {}'.format(cls.__name__))

SomeClass.hello() # Hello, класс SomeClass
```
####Типы
Неизменяемые (в функциях передается независимая копия)
**Numbers** (числа) int float complex
**Strings** (строки) неизменяемый упорядоченный тип данных, последовательность символов, заключенная в кавычки. Сырые строки r'dgsg/'. выключено экранирование, в основном для регулярок. b'fwfw' bytes ,fqnjdst cnhjrb
**Tuples** (кортежи) неизменяемый упорядоченный тип данных. (1,2,3,3)

Изменяемые
**Lists** (списки) 
**Dictionaries** (словари)
**Sets** (множества) это изменяемый неупорядоченный тип данных. В множестве всегда содержатся только уникальные элементы. {1,2,3}
**Frozensets** неизменяемый set 
**Boolean** (логический тип данных)

## ООП
https://javarush.ru/groups/posts/1966-principih-obhhektno-orientirovannogo-programmirovanija
- **Наследование** — механизм, который позволяет описать новый класс на основе существующего (родительского). При этом свойства и функциональность родительского класса заимствуются новым классом.
- **Абстракция** означает выделение главных, наиболее значимых характеристик предмета и наоборот — отбрасывание второстепенных, незначительных.
- **Инкапсуляция** в Java означает ограничение доступа к данным и возможностям их изменения.
- **Полиморфизм** — это возможность работать с несколькими типами так, будто это один и тот же тип. При этом поведение объектов будет разным в зависимости от типа, к которому они принадлежат.

###Q&A
