https://ivan-shamaev.ru/data-engineering-etl-pipeline-data-warehouse-datalake/
https://tproger.ru/curriculum/data-engineer-interview-guide/
https://bozaro.github.io/tech-db-lectures/
## SQL


#### DDL – Data Definition Language
CREATE – используется для создания объектов базы данных;
ALTER – используется для изменения объектов базы данных;
DROP – используется для удаления объектов базы данных.

#### DML – Data Manipulation Language
SELECT – осуществляет выборку данных;
INSERT – добавляет новые данные;
UPSERT
REPLACE
UPDATE – изменяет существующие данные;
DELETE – удаляет данные.

#### DCL – Data Control Language
GRANT – предоставляет пользователю или группе разрешения на определённые операции с объектом;
REVOKE – отзывает выданные разрешения;
DENY– задаёт запрет, имеющий приоритет над разрешением.

#### TCL – Transaction Control Language
BEGIN TRANSACTION – служит для определения начала транзакции;
COMMIT TRANSACTION – применяет транзакцию;
ROLLBACK TRANSACTION – откатывает все изменения, сделанные в контексте текущей транзакции;
SAVE TRANSACTION – устанавливает промежуточную точку сохранения внутри транзакции.

---

##### Транзакция  
- упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое. Потом 
**COMMIT** - применяем изменения
**ROLLBACK** - откатываем изменения
До закрытия транзакции изменения сохраняются «виртуально»  и после коммита применяются фактически.
Если не делать коммит или ролбек и вернуть конекш(подключение) в пул подключений, то другой человек можем подтвердить изменения прошлого
###### Проблемы параллельного использования транзакций:
1. **Потерянное обновление** - когда у нас в результате изменения блока данных разными транзакциями, сохраняется только последняя.
2. **Грязное чтение** - когда мы можем прочитать данные, которые в последствии откатятся.
3. **Неповторяющееся** чтение - когда у нас в рамках одной транзакции. Чтение одних и тех же данных даёт разный результат 
4. **Фантомное чтение** - когда у нас в рамках одной транзакции есть выборка нескольких строк, а в итоге мы получаем разное количество. 

###### Уровни изоляции транзакций:
1. **Read uncommitted (чтение незафиксированных данных)** - Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно, фактически выполнятся последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются.
2. **Read committed (чтение фиксированных данных)** - пишущая транзакция блокирует изменяемые данные для читающих транзакций, работающих на уровне read committed или более высоком, до своего завершения, препятствуя, таким образом, «грязному» чтению, а данные, блокируемые читающей транзакцией, освобождаются сразу после завершения операции SELECT
3. **Repeatable read (повторяющееся чтение)** - Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие условиям поиска инструкций, содержащихся в текущей транзакции.
4. **Serializable (упорядочиваемость)** - Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения».

###### ACID
* **Atomicity — Атомарность** гарантирует, что никакая транзакция не будет зафиксирована в системе частично. 
Будут либо выполнены все её подоперации, либо не выполнено ни одной.
* **Consistency — Согласованность**
Транзакция, достигающая своего нормального завершения и, фиксирующая свои результаты, сохраняет согласованность базы данных.
Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты.
* **Isolation — Изолированность**
Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.
* **Durability — Долговечность**
Независимо от проблем на нижних уровнях (к примеру, сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу.

###### Термины
* **Первичный ключ** - (выбранный потенциальный ключ - обладает свойствами уникальности и минимальности) уникальный ключ для идентификации записи в таблице.
* **Внешний ключ** — это столбец или сочетание столбцов, которое применяется для принудительного установления связи между данными в двух таблицах с целью контроля данных, которые могут храниться в таблице внешнего ключа.
* **Индекс** в базах данных — это файл с последовательностью пар ключей и указателей на запись в таблице.
* **Представление** (англ. view, иногда используются названия «вид», «взгляд») — виртуальная (логическая) таблица, представляющая собой поименованный запрос (синоним к запросу), который будет подставлен как подзапрос при использовании представления. 
В отличие от обычных таблиц реляционных баз данных, представление не является самостоятельной частью набора данных, хранящегося в базе. Содержимое представления динамически вычисляется на основании данных, находящихся в реальных таблицах. Изменение данных в реальной таблице базы данных немедленно отражается в содержимом всех представлений, построенных на основании этой таблицы.

Некоторые СУБД имеют расширенные представления для данных, доступных только для чтения. Так, СУБД Oracle реализует концепцию «материализованных представлений» — представлений, содержащих предварительно выбранные невиртуальные наборы данных, совместно используемых в распределённых базах данных. Эти данные извлекаются из различных удалённых источников (с разных серверов распределённой СУБД). Целостность данных в материализованных представлениях поддерживается за счёт периодических синхронизаций или с использованием триггеров. Аналогичный механизм предусмотрен в Microsoft SQL Server версии 2000.

* **Храни́мая процеду́ра (англ. Stored procedure)** — объект базы данных, представляющий собой набор SQL-инструкций, который компилируется один раз и хранится на сервере. Можно использовать перехват ошибок, нельзя вызывать в SELECT.

Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения

* **Триггер** - хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением INSERT, удалением DELETE строки в заданной таблице, или изменением UPDATE данных в определённом столбце заданной таблицы реляционной базы данных. 

* **Курсор** — это поименованная область памяти, содержащая результирующий набор select запроса. Второе определение — это механизм обработки результирующего набора select запроса.



WINDOW w AS (
PARTITION BY 
ORDER BY
ROWS
)
Границы можно определять рядом выражений:
![image](https://user-images.githubusercontent.com/53166911/179399093-41af7cf4-038e-40f0-a894-9fc77d54cf0c.png)
<img src="[https://github.com/favicon.ico](https://user-images.githubusercontent.com/53166911/179399093-41af7cf4-038e-40f0-a894-9fc77d54cf0c.png)" width="48">
N PRECEDING, N строк до текущей строки
CURRENT ROW, текущая строка
UNBOUNDED PRECEDING, все строки, предшествующие текущей
UNBOUNDED FOLLOWING, все последующие строки
N FOLLOWING, N строк после текущей строки

UNBOUNDED PRECEDING — указывает, что окно начинается с первой строки группы;
UNBOUNDED FOLLOWING – с помощью данной инструкции можно указать, что окно заканчивается на последней строке группы;
CURRENT ROW – инструкция указывает, что окно начинается или заканчивается на текущей строке;
BETWEEN «граница окна» AND «граница окна» — указывает нижнюю и верхнюю границу окна;
«Значение» PRECEDING – определяет число строк перед текущей строкой (не допускается в предложении RANGE).;
«Значение» FOLLOWING — определяет число строк после текущей строки (не допускается в предложении RANGE).
